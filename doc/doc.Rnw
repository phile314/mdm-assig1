\documentclass[12pt, a4paper, oneside]{report}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{subcaption}

% font size could be 10pt (default), 11pt or 12 pt
% paper size coulde be letterpaper (default), legalpaper, executivepaper,
% a4paper, a5paper or b5paper
% side coulde be oneside (default) or twoside 
% columns coulde be onecolumn (default) or twocolumn
% graphics coulde be final (default) or draft 
%
% titlepage coulde be notitlepage (default) or titlepage which 
% makes an extra page for title 
% 
% paper alignment coulde be portrait (default) or landscape 
%
% equations coulde be 
%   default number of the equation on the rigth and equation centered 
%   leqno number on the left and equation centered 
%   fleqn number on the rigth and  equation on the left side
%   
\title{MDM Assignment 1}
\author{Marco Vassena  \\
    4110161 \\
    \and 
    Philipp Hausmann \\
    4003373 \\
    }

\date{\today} 
\begin{document}

<<setup, echo=FALSE, cache=TRUE,include=FALSE>>=
library(knitr)
opts_chunk$set(echo=FALSE)

source('../src/common.r', chdir=TRUE)

dat_perf <- read_data('../data/spambase.data', 0.0)
dat_pars <- read_data('../data/spambase.data', 0.7)

nrep <- 1
source('../src/functional.r', chdir=TRUE)
source('../src/ctree.r', chdir=TRUE)
@

\maketitle

\tableofcontents


\section{Problem description}
The goal of this assignment is to implement and evaluate a tree classification algorithm.
In addition to that, we will also discuss two different implementation styles
and their performance implications.

\section{Implementations}
We created two implementations of the algorithm. The first one is idiomatic R code,
whereas the second one is inspired by what a functional implementation looks like.
Both algorithms produce the same results, they may only differ performance-wise.

\subsection{Basic Functions}
First, we would like to discuss the functions common to both implementations.
The file \texttt{common.r} contains procedures shared between the two implementations.

  Binary attributes considered as numerical
  No optimization in best.split.on due to the nmin constraint

\subsection{Imperative/R Style}
The classification tree is implemented as a non-empty data frame with the following columns: \texttt{left}, \texttt{right}, \texttt{label}, \texttt{split}, \texttt{splitCol}. Each row represents either a leaf or an internal node and the first row is the root of the tree.
The \texttt{leaf} and \texttt{right} field of a node row contains the index of the row of the same data frame at which the correspondent left and right child is to be found.
The \texttt{split} and \texttt{splitCol} are used by the classify procedure. The first is the threshold value
and the second is the column number of the attribute referred by the first.
The field \texttt{label} is set to \texttt{na} for node rows.
Leaves nodes fields are all set to \texttt{na} except for \texttt{label} which contains the predicted class label (0 or 1), computed using majority vote. Ties are broken at random.
The related source code can be found in the file \texttt{ctree.r}.

\subsection{Functional Style}
The functional style version encodes the tree by simulating objects in R. We
would like to note that R is not perfectly suited for this approach, but it
should give some indications how such an approach compares in term of
performance to a more procedural/imperative approach. The source code can
be found in the file \texttt{functional.r}.

The implementation basically uses recursion to construct the tree, which happens
in the \texttt{tree.functional.grow} function. A nice side effect of the functional
approach is, that the tree is never modified and the recursive approach could easily
be parallelized (in general, not necessarily in R).

\section{Results}
\subsection{Performance comparison}
\begin{figure}[!ht]
<<perf-comp-comp,cache=TRUE,echo=FALSE>>=
ti_fu_gr <- system.time(replicate(nrep, tree.functional.grow(dat_perf$trxs, dat_perf$trys, 5, 5)))["elapsed"]
ti_im_gr <- system.time(replicate(nrep, tree.grow(dat_perf$trxs, dat_perf$trys, 5, 5)))["elapsed"]

fu_t <- tree.functional.grow(dat_perf$trxs, dat_perf$trys, 5, 5)
im_t <- tree.grow(dat_perf$trxs, dat_perf$trys, 5, 5)

ti_fu_pr <- system.time(replicate(nrep, tree.functional.classify(dat_perf$trxs, fu_t)))["elapsed"]
ti_im_pr <- system.time(replicate(nrep, tree.classify(dat_perf$trxs, im_t)))["elapsed"]
@
<<perf-comp-plot,fig.keep='high',cache=FALSE,echo=FALSE>>=
barplot(c(ti_fu_gr, ti_im_gr, ti_fu_pr, ti_im_pr), names.arg = c("grow functional", "grow imperative", "predict functional", "predict imperative"))
@
\end{figure}

\subsection{Parameter search}
<<par-search-comp,cache=TRUE,echo=FALSE>>=
ps_pars <- list( 
                list(nmin = 0, minleaf = 0)
)
ps_lbls <- list(
                "nmin = 0, minleaf = 0"
)
e_ps <- eval_mthd(dat_pars, ps_lbls, ps_pars, eval_with_pars)
@
<<par-search-tbl,cache=FALSE,results='asis',echo=FALSE>>=
kable(eval_to_matrix(e_ps))
@


\begin{thebibliography}{1}

\bibitem{FS91}
  Peter W. Frey, David J. Slate.
  \emph{Letter Recognition Using Holland-Style Adaptive Classifier}.
  Kluwer Academic Publishers,
  Machine Learning, 6, 161-182(1991).
  Tom Dietterich, Boston,
  1991.

\end{thebibliography}

\end{document}
